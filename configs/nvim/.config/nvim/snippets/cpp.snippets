snippet po "pragma once directive" b
    #pragma once
snippet cla "class"
    class $1
    {
    public:
        $2
    private:
    };
snippet str "struct"
    struct $1
    {
        $2
    };
snippet la "lambda" i
    []($1){$2}
snippet l1 "one argument generic lamdba" i
    [](const auto& $1) { $2 }
snippet l2 "two argument generic lamdba" i
    [](const auto& $1, const auto& $2) { $3 }
snippet iq "include quotes" b
    #include "$1"
snippet ib "include brackets" b
    #include <$1>
snippet iv "include vector" b
    #include <vector>
snippet ii "include iostream" b
    #include <iostream>
snippet is "include string" b
    #include <string>
snippet io "include optional" b
    #include <optional>
snippet im "include memory" b
    #include <memory>
snippet main "main() (main)" b
    int main(int argc, char *argv[])
    {
        $0
        return 0;
    }
snippet fr "for range loop"
    for ($1 : $2)
    {
    $3
    }
snippet fi "for counter"
    for (int i = 0; i < $1; ++i)
    {
        $2
    }
snippet ns "namespace"
    namespace $1
    {
    $2
    }
snippet nsa "anonymous namespace"
    namespace
    {
    $1
    }
snippet cout "std::cout"
    std::cout << $1 << std::endl;
snippet if "if clause"
    if ($1)
    {
        $2
    }
snippet el "else clause"
    else {
        $0
    }
snippet fdef "function definition"
    auto $1($2) -> ${3:void}
    {
        $0
    }
snippet fdec "function declaration"
    auto $1($2) -> ${3:void}
snippet mdef "member function definition"
    auto $1::$2($3) -> ${4:void}
    {
        $0
    }
snippet todo "TODO"
    // TODO: $0
snippet vc "void cast"
    (void) $0;
snippet ve "std::vector" i
    std::vector<$1>
snippet fp "std::filesystem::path" i
    std::filesystem::path
snippet up "std::unique_ptr" i
    std::unique_ptr<$1>
snippet mun "std::make_unique" i
    std::make_unique<$1>($2)
snippet sp "std::shared_ptr" i
    std::shared_ptr<$1>
snippet msa "std::make_shared" i
    std::make_unique<$1>($2)
snippet st "std::string" i
    std::string
snippet re "return"
    return ${1:\{\}};
snippet cr "const reference" i
    const $1& $0
snippet ad "auto variable declaration"
    auto $1 = $2;
snippet ar "auto reference" i
    auto& $0
snippet ca "const auto" i
    const auto $0
snippet car "const auto reference" i
    const auto& $0
snippet cap "const auto pointer" i
    const auto* $0
snippet sci "static cast int" i
    static_cast<int>($1)
snippet sc "static cast" i
    static_cast<$1>($2)
snippet be "begin end iterator pair" i
    $1.begin(), $1.end()
snippet cbe "begin end const iterator pair" i
    $1.cbegin(), $1.cend()
snippet mu "maybe_unused" i
   [[maybe_unused]]
snippet nd "nodiscard" i
   [[nodiscard]]
snippet do "default operations"
    $1(const $1&) = delete;
    $1& operator=(const $1&) = delete;
    $1($1&&) = delete;
    $1& operator=($1&&) = delete;
snippet dot "default operations trailing return type"
    $1(const $1&) = delete;
    auto operator=(const $1&) -> $1& = delete;
    $1($1&&) = delete;
    auto operator=($1&&) -> $1& = delete;
snippet ig "include guard"
    #ifndef $1_H_
    #define $1_H_
    #endif
snippet doc "doxygen doc"
    /**
    * @brief $0
    */
snippet mi "std::chrono::milliseconds" i
    std::chrono::milliseconds
snippet mv "std::move" i
    std::move($0)
snippet op "std::optional" i
    std::optional<$1>
snippet oo "define std::ostream operator"
    inline auto operator<<(std::ostream& os, const $2& value) -> std::ostream&
    {
        os << $0;
        return os;
    }
snippet eo "define equality operations"
    inline auto operator==(const $2$ lhs, const $2$ rhs) -> bool
    {
        return $0;
    }

    inline auto operator!=(const $2$ lhs, const $2$ rhs) -> bool
    {
        return !(lhs == rhs);
    }
snippet tc "try catch block"
    try
    {
        $2
    } catch($1) {
        $0
    }
snippet cat "catch block"
    catch($1) {
        $0
    }
